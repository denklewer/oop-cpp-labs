// Laba1.cpp: определяет точку входа для консольного приложения.
// ПРОМЕЖУТОЧНЫЙ РЕЗУЛЬТАТ, ЕСТЬ ВОПРОСЫ
#include "stdafx.h"

int n;	 // Глобальная переменная. По умолчанию она обнуляется.

namespace space	 // В пространстве имен - space
{
	int n = 1;	 // Объявлена переменная n
}				 // space определяет область видимости этой переменной

void  main()
{
	setlocale(LC_CTYPE, ".1251");		// Функция установки нашей кодовой страницы
	setlocale(LC_MONETARY, ".1251");
	// Выполняя программу по шагам, следите за значениями переменных  и интерпретируйте результат, объясняя себе
	// наблюдаемые значения. Обратите внимание на разную интерпретацию отладчиком  signed и unsigned типов данных.
	char c = 'A'; // 65 'A' 0x41 
	// В комментарии справа полезно проставить десятичное символьное и шестнадцатиричное 
	// значения переменной после выполнения указанной строки. Вы должны видеть их в окне Autos.
	c = 0x42;		// 66 'B' 0x42
	c = -1;		// -1 'я' 0xff
	c = CHAR_BIT;	 // Размер переменной типа char 8
	stop;

	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф'; // 1060
	size_t ns = sizeof(cw);  //2 байта

	unsigned char uc = 0x41; // 65 'A'
	uc = 'B'; // 66 'B'
	uc = -1;  // 255 'я'
	stop;

	int i = 1;
	i = -1;
	stop;

	unsigned int ui = 1;
	ui = -1; // 4294967295 

	unsigned 	 short  s = 0xffff;	 // Здесь compiler генерирует warning (different data types)
	s = short(0xffff);
	s = 1;

	//==== Измените код, чтобы убрать warnings
	unsigned short us = 0xffff;
	us = 5;

	long l = 0xffffffff; // -1 long по-умолчанию signed , так что код соответствует самому большому отрицательному числу
	l = -128;

	l = FLT_MAX_EXP;	// Все эти константы вы должны найти в файле limits и объяснить их смысл с помощью рисунка| максимальная экспонента флота, максимальный показатель степени двойки для флота
	l = DBL_MAX_EXP;  // максимальная экспонента для дабла 1024    (всего от -1024 до +1024)

	l = FLT_MANT_DIG;  // количество бит в мантиссе флота, 23+1 кол-во знаков после запятой в двоичном представлении
	l = DBL_DIG;  // число десятичных разрядов точности в дабле, 15  у флоата 6 

	l = FLT_MANT_DIG;  // количество бит в мантиссе флота, 23+1 кол-во знаков после запятой в двоичном представлении
	l = DBL_MANT_DIG;// количество бит в мантиссе дабла, 52+1 кол-во знаков после запятой в двоичном представлении

	double f = -12.56;	 // Здесь warning. Уберите его.  ??????????????????????????????????????????????????????????
	f = -1.e-27f;

	f = FLT_MAX;
	f = FLT_MIN;

	double d = 0.1234567890123456789123456789;   // 9 отрезается, т.к. не помещается в дабл 15 знаков
	d = -0.123456789012345e+306; // аналог
	d = DBL_MAX;   // максимальное значение дабла
	d = DBL_MIN;   // минимальное положительное значение дабла
	d = DBL_EPSILON; // Самая маленькая разность между двумя пер-ми типа double

	uc = ~0;		 // Побитовое отрицание  было 255 я,  осталось таким же. т.к. отрицание 0.
	i = ~0;  // стало -1,  т.к. Signed int.
	stop;
	// Раннее (при компиляции) или неявное приведение типов данных
	// Объясните те значения, которые вы наблюдаете в окне Autos. Определите порядок выполения присваиваний.
	d = f = i = s = c = 1 / 3;  // привсвоение справа налево . 1/3 это 0 в чаре. 
	c = s = i = f = d = 100 / 3; // делим целые числа
	c = s = i = f = d = 10 / 3;
	c = s = i = f = d = 1 / 3.; // указали, что 3 с точкой.

	// Пример "небрежного" использования неявного приведения типов.	 Объясните результаты.
	i = 256;
	c = i;//  256 не помещается в чар , и берется как бы по модулю 256

	uc = 255;
	unsigned char u = 2, sum = uc + u; // опять же при переполнении берем по модулю
	stop;

	// Явное приведение типов	Объясните разницу результатов в строках (3) и (4)
	i = 100;
	f = d = i / 3;							// (3) делим 2 целых числа, значит ожидаем целое число
	f = d = (double)i / 3;		// (4) указываем, что преобразовать и в дабл сначала
	f = d = double(i) / 3;			// (4)
	f = d = static_cast<double>(i) / 3;		// (4)  статик опасен, т.к. не проверяет возможность преобразования
	stop;

	// Область действия, область видимости и время существования. В этом фрагменте фигурируют четыре
	//  переменных с одним и тем же именем n.  Одна - глобальная, вторая определена в своем пространстве имен,
	// третья - локальная внутри функции main(), четвертая - локальная внутри блока. 
	//  Обратите внимание, что глобальная переменная и та, что в пространстве имен space - объявлены вне функции main()
	// Определите, к какой из четырех переменных идет обращение, cформулируйте область действия и область видимости
	// каждой переменной. Для выполнения задания рекомендуется пользоваться  закладкой "Watches" или "Locals" окна
	// "Autos". Подсказка: В окно "Watches" можно поместить сразу все переменные (n, ::n, и space::n)
	n = 100;  // глобальная переменная видна везде
	space::n = 200; // ??????????????????
	n++;  // глобальная переменная видна везде
	int n;		//Где живет эта переменная ?  локальная переменная, видна только в main
	n = 10; //   теперь все такие обращения только к локальной переменной
	::n++;   //глобальная переменная

	{				//  Начало блока
		int n;		// Эта переменная живет внутри блока
		n = -1;  // переменная этого блока
		n++; // переменная этого блока
		::n++;  // глобальная
		space::n++;  // переменная space 
	}		// Конец блока
	n--;  // локальная, видна в main
	::n--;  // глоб
	space::n--;  // space

	// Спецификатор класса памяти - static Выполняя задание по шагам, обратите внимание на  разное поведение
	// переменных nLoc и nStat
	{
	Again:
		int outer;
		for (int i = 0; i < 5; i++)
		{
			static int nStat;   // nstat существует всегда, значение увеличивается
			{
				int nLoc = 0;  // nloc каждый раз создается заново
				nLoc++;		nStat++;
			}
			outer = nStat;
		}
		if (outer < 10)
			goto Again;
	}
	// Перечисления - enum. Обратите внимание на явную и неявную инициализацию констант
	enum RANK
	{
		eSoldier,
		eSergeant,
		eCorporal,
		eLieutenant,
		eCaptain = 6,
		eMajor,
		eColonel = eMajor + 3,
		eGeneral = 20
	};
	typedef RANK RANG;

	RANG r = eSoldier;
	if (r == eSoldier)
		r = eSergeant;

	if (r == eSergeant)
	{
		// Любой целочисленной переменной можно присвоить enum-переменную 
		int i = r;
		r = RANK(i++);		// Обратное преобразование надо указывать явно
		i = r;
		r = RANK(++i);
		i = r; // 100 ???
	}
	RANK rr = eColonel; // 10 
	stop;
	//	Логический тип bool.	Выполняя задание по шагам, следите за значениями переменной b
	{
		int n = 127;
		bool b = n != 0; // true
		b = n == 0;//false
		b = n > 0; // true
		b = n <= 0;//false
		b = n > 1;// true

		int num = static_cast<int>(b);
		if (b)
			cout << "\n\t My flag is: true" << "   or: " << b
			<< "\n\t Conversion to int: " << num << endl;
		b = n == num;
		cout << "\n\t Now the flag is: false" << "   or: " << b;
	}

	//	Модификатор const
	const double pi = acos(-1.);
	double space_permiability = 4.e-7 * pi;		//	Магнитная проницаемость пустоты
	const int dozen = 12;
	int var = dozen;

	//	Раскомментируйте следующую строчку и объясните ошибку компиляции (l-value означает left value)
	//	dozen = 1; слева в выражении стоит  недопустимое для изменения значение
	//	Директивы условной трансляции. Объясните значение, которое принимает переменная version.
	//	Что нужно сделать для того, чтобы результат был другим?
#define _MSVER400
	char *version;  // спросить.?????
#if defined _MSVER400
	version = "version 4.00";
#elif defined _MSVER311
	version = "version 3.11";
#else
	version = "version Unknown";
#endif

	cout << endl << version;
	stop;

	//В окне ClassView или Solution Explorer поставьте фокус на имя проекта дайте команду Project/Properties.
	//	В диалоге Property Pages щелкните на папке Configuration Properties, убедитесь, что в разделе Code Generation
	//	установлена константа компиляции _DEBUG. Создайте директивы препроцессора и код С++, которые
	//	в зависимости от действующей конфигурации проекта (_DEBUG или NDEBUG) выводят соответствующее
	//	сообщение. Измените конфигурацию проекта (в диалоге Property Pages) и проверьте ваш код.
	//	Чтобы изменить конфигурацию пользуйтесь кнопкой Configuration Manager

	//	Простейшие циклы. Объясните суть происходящего. 
	{
		// Цикл while надо использовать, когда неизвестно количество итераций (повторений) цикла.
		// Операция & — это побитовое AND.  Операция &= — это побитовое AND с присвоением.
		// Если непонятно, то прочтите документ Операции языка С.doc
		cout << "\n\nGradually eat out all the units:\n\n";
		unsigned short us = 0xff;
		while (us)
		{
			cout << hex << us << endl;
			us &= us - 1;
		}
		cout << hex << us << "\nDone\n";
		// Цикл for надо использовать, когда известно количество итераций и/или есть код подготовки.
		// Подсказка: odd - нечетое, even - четное.
		cout << "\n\nShow even-odd:\n\n";
		for (int i = 0; i < 10; i++)
		{
			if (i & 1)
				cout << i << " - odd\n";
			else
				cout << i << " - even\n";
		}
		// Цикл do-while программисты не любят, так как они требуют 
		// большего напряжения при разгадке своей логики.



		char c = ' ';

		do
		{
			if (c == 'a')
				cout << "\nAction is a delegate type in C#";
			else if (c == 'b')
				cout << "\nbreak is one of the 'leave' statements in all C-like languages";
			else if (c == 'c')
				cout << "\ncontinue is a 'go on' statement in all C-like languages";
			else if (c == 'd')
				cout << "\ndo-while is a rarely used loop statement in all C-like languages";
			else
				cout << "\nPlease read the rules of this loop";
			cout << "\n\nEnter chars: a, b, c, d (q - to quit):\n\n";
			cin >> c;
			if (c == 'q')
				cout << "\nI am going to leave the loop\n";
		} while (c != 'q');
		stop;
	}
	//	Логические условные операторы и циклы. Функция y = f(x) задана графиком
	//	Напишите фрагмент кода, который с шагом 0.1 вычисляет y = f(x)  и выводит в консольное окно значения x и y. 
	//	     y
	//	    | 
	//	   2|________
	//	    |         /\
		//	    |        /  \
		//	    |       /    \
		//	    |______/      \__________  x
	//	    0      1   2   3
	//	 Реализуйте 2 варианта этого алгоритма:   1. Используйте операторы if	 2. Используйте тернарные операции    ? :

	//	Напишите фрагмент, который с помощью for и switch реализует следующую логику. Если пользователь ввел:
	//	символ 'a',   ваш алгоритм выводит  "Ok" (в кавычках)
	//	символ 'b',   ваш алгоритм выводит  Bell (alert - звуковой сигнал)
	//	символ 'с',   ваш алгоритм выводит  число, которое равно количеству введенных символов
	//	символ 'Esc', ваш алгоритм выводит  "to quit use 'q'"
	//	символ 'q',   ваш алгоритм выводит  "Bye" и выходит из цикла ввода

	//	Побитовые операции:  |, &, ~, ^ и сдвиги >>, <<
	//	Поменяйте местами байты переменной flags и выведите результат в консолное окно unsigned short flags = 0xaabb;
	//	Ваш код
	unsigned short flags = 0xaabb;
	flags = (flags << 8) + (flags >> 8);
	
	cout << "\n bits = " << hex << flags;
	//	Для вывода в шестнадцатеричном виде используйте  cout <<"\n bits = " << hex << flags;
	//	В переменной unsigned char byte = 0x26; установите в единицу 3-й бит (счет от нуля). Выведите результат.
	unsigned char byte = 0x26;
	cout << "\n   byte 1=" << hex << (int)byte;;
	byte = byte | 8;

	cout << "\n   byte 2=" << hex << (int)byte;


	//	Затем инвертируйте два младших бита. Выведите результат. Обнулите 4 младших бита. Выведите результат
		byte = byte ^ 3;
		cout << "\n   byte 3=" << hex << (int)byte;
		// обнуление 4 битов младших
		byte = (byte / 16) << 4;

		cout << "\n   byte 3=" << hex << (int)byte;

	cout << "\n\n";
	// задача 1. оператор if
	double x = 0.0;
	do
	{
		if (x < 1)
			cout << x << " -  y = " << " 0 \n";
		else if (x < 2)
			cout << x << " - y = " << 2 * x - 2 << "\n";
		else if (x < 3)
			cout << x << " - y = " << 6 - 2 * x << "\n";
		else
			cout << x << " -  y = " << " 0 \n";
		x = x + 0.1;
	} while (x <= 4);

	stop;
	// задача 2. тернарная операция.
	x = 0.0;
	double rez;
	do
	{

		rez = x < 1 ? 0 : (x < 2 ? 2 * x - 2 : (x<3 ? 6 - 2 * x : (x>0 ? 0 : (-1))));
		cout << x << " - y = " << rez << "\n";
		x = x + 0.1;
	} while (x <= 4);
	stop;


	// задача 3. использование for   и switch
	cout << "insert a char \n";



	char in;

	for (int i = 0; in != 'q'; i++){
		in = _getch();
		switch (in)
		{
		case 'a': cout << "\"Ok\" \n"; continue;
		case 'b': cout << '\a'; continue;
		case 'c': cout << dec<< i <<"\n"; continue;
		case 'q': cout << "Bye\n"; continue;
		case 27: cout << "to quit use 'q' \n"; continue;

		default: cout << "Введён не верный символ\n";
			break;
		}
	}


}	// Конец функции main()
